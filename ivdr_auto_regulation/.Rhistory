readRDS(df, file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
print(head(df))
df <- readRDS(file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
print(head(df))
df |> dplyr::filter(grepl(article == "art"))
df |> dplyr::filter(grepl("^art", article))
df <- df |> dplyr::filter(grepl("^art", article))
print(head(df))
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle)
print(head(df))
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle) |> head()
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle) |> head()
df <- readRDS(file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle) |> head()
print(df)
kable(df)
names(df)
```{r read_article, echo=FALSE, message=FALSE}
df <- readRDS(file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
names(df)
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle, content) |> head()
print(df)
# Wrap the content column to a maximum of 60 characters per line
df$content <- wrap_text(df$content, width = 60)
# Custom function to truncate text at a specified length
truncate_text <- function(text, length = 60) {
sapply(text, function(x) {
if (nchar(x) > length) {
return(paste0(substr(x, 1, length), "..."))
} else {
return(x)
}
})
}
# Truncate the content column to a maximum of 60 characters
df$content <- truncate_text(df$content, length = 60)
kable(df)
# Custom function to remove excess whitespaces
remove_excess_whitespace <- function(text) {
sapply(text, function(x) {
gsub("\\s+", " ", x)
})
}
# Remove excess whitespaces from the content column
df$content <- remove_excess_whitespace(df$content)
kable(df)
library(kableExtra)
library(DBI)
library(knitr)
library(dplyr)
library(igraph)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
kable <- function(data) {
knitr::kable(data, format="latex", longtable = FALSE, booktabs=FALSE) %>%
kable_styling(latex_options =c("striped", "scale_down", "HOLD_position"))
}
# Install kableExtra package if you haven't
# if (!requireNamespace("kableExtra", quietly = TRUE))
#   install.packages("kableExtra")
# Define global variables for the database connection to ensure it stays open
run_id <- params$run_id
dbname <- "DNAsnake_IVDR.db"
# Connect to the database
db <- dbConnect(RSQLite::SQLite(), dbname = dbname)
# Ensure the database connection is valid
if (dbIsValid(db)) {
print("SQL database connection is active and ready.")
} else {
stop("Failed to establish a connection to the database.")
}
# Define the function to retrieve run details, including reference genome information
getRunDetails <- function(run_id) {
query <- sprintf("
SELECT
r.run_id,
r.run_date,
r.status,
r.sample_id,
s.collection_date,
s.source,
a.analysis_type,
a.result,
m.key,
m.value AS metadata_value,
rg.name AS genome_name,
rg.version AS genome_version,
sc.component_name,
sc.component_version,
gl.commit_id
FROM
Runs r
JOIN Samples s ON r.sample_id = s.sample_id
JOIN Analyses a ON r.run_id = a.run_id
JOIN Metadata m ON r.run_id = m.run_id
JOIN SystemComponents sc ON r.run_id = sc.run_id
JOIN GitLog gl ON sc.component_id = gl.component_id
LEFT JOIN ReferenceGenomes rg ON m.value = rg.reference_id AND m.key = 'Reference Genome'
WHERE
r.run_id = '%s'", run_id)
dbGetQuery(db, query)
}
# Retrieve run details
run_details <- getRunDetails(run_id)
print(run_details)
# kable(run_details, format="latex", longtable = FALSE, booktabs=FALSE,  position = "H") %>%
# kable_styling(latex_options="scale_down")
df <- readRDS(file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
# df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle, content) |> head()
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, content) |> head(20)
# Custom function to remove excess whitespaces
remove_excess_whitespace <- function(text) {
sapply(text, function(x) {
gsub("\\s+", " ", x)
})
}
# Remove excess whitespaces from the content column
df$content <- remove_excess_whitespace(df$content)
# Custom function to truncate text at a specified length
truncate_text <- function(text, length = 60) {
sapply(text, function(x) {
if (nchar(x) > length) {
return(paste0(substr(x, 1, length), "..."))
} else {
return(x)
}
})
}
# Truncate the content column to a maximum of 60 characters
df$content <- truncate_text(df$content, length = 60)
kable(df)
df$linked_to_network <- "No"
df_tail <- df |> tail(10)
df <- df |> head(20)
df <- readRDS(file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
df$linked_to_network <- "No"
# df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle, content) |> head()
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, content)
# Custom function to remove excess whitespaces
remove_excess_whitespace <- function(text) {
sapply(text, function(x) {
gsub("\\s+", " ", x)
})
}
# Remove excess whitespaces from the content column
df$content <- remove_excess_whitespace(df$content)
# Custom function to truncate text at a specified length
truncate_text <- function(text, length = 80) {
sapply(text, function(x) {
if (nchar(x) > length) {
return(paste0(substr(x, 1, length), "..."))
} else {
return(x)
}
})
}
# Truncate the content column to a maximum of 60 characters
df$content <- truncate_text(df$content, length = 60)
# display
df_tail <- df |> tail(10)
df <- df |> head(20)
kable(df)
kable(df_tail)
View(df_tail)
row.names(df)
row.names(df_tail)
kable(df_tail, row.names = NULL)
knitr::kable(data, format="latex", longtable = FALSE, booktabs=FALSE,  row.names = NULL) %>%
kable_styling(latex_options =c("striped", "scale_down", "HOLD_position"))
library(kableExtra)
library(DBI)
library(knitr)
library(dplyr)
library(igraph)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
kable <- function(data) {
knitr::kable(data, format="latex", longtable = FALSE, booktabs=FALSE) %>%
kable_styling(latex_options =c("striped", "scale_down", "HOLD_position"))
}
# Install kableExtra package if you haven't
# if (!requireNamespace("kableExtra", quietly = TRUE))
#   install.packages("kableExtra")
# Define global variables for the database connection to ensure it stays open
run_id <- params$run_id
dbname <- "DNAsnake_IVDR.db"
# Connect to the database
db <- dbConnect(RSQLite::SQLite(), dbname = dbname)
# Ensure the database connection is valid
if (dbIsValid(db)) {
print("SQL database connection is active and ready.")
} else {
stop("Failed to establish a connection to the database.")
}
# Define the function to retrieve run details, including reference genome information
getRunDetails <- function(run_id) {
query <- sprintf("
SELECT
r.run_id,
r.run_date,
r.status,
r.sample_id,
s.collection_date,
s.source,
a.analysis_type,
a.result,
m.key,
m.value AS metadata_value,
rg.name AS genome_name,
rg.version AS genome_version,
sc.component_name,
sc.component_version,
gl.commit_id
FROM
Runs r
JOIN Samples s ON r.sample_id = s.sample_id
JOIN Analyses a ON r.run_id = a.run_id
JOIN Metadata m ON r.run_id = m.run_id
JOIN SystemComponents sc ON r.run_id = sc.run_id
JOIN GitLog gl ON sc.component_id = gl.component_id
LEFT JOIN ReferenceGenomes rg ON m.value = rg.reference_id AND m.key = 'Reference Genome'
WHERE
r.run_id = '%s'", run_id)
dbGetQuery(db, query)
}
# Retrieve run details
run_details <- getRunDetails(run_id)
print(run_details)
# kable(run_details, format="latex", longtable = FALSE, booktabs=FALSE,  position = "H") %>%
# kable_styling(latex_options="scale_down")
# display
df_tail <- df[103:113, ]
df <- df[1:10, ]
library(kableExtra)
library(DBI)
library(knitr)
library(dplyr)
library(igraph)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
kable <- function(data) {
knitr::kable(data, format="latex", longtable = FALSE, booktabs=FALSE, row.names = FALSE) %>%
kable_styling(latex_options =c("striped", "scale_down", "HOLD_position"))
}
# Install kableExtra package if you haven't
# if (!requireNamespace("kableExtra", quietly = TRUE))
#   install.packages("kableExtra")
# Define global variables for the database connection to ensure it stays open
run_id <- params$run_id
dbname <- "DNAsnake_IVDR.db"
# Connect to the database
db <- dbConnect(RSQLite::SQLite(), dbname = dbname)
# Ensure the database connection is valid
if (dbIsValid(db)) {
print("SQL database connection is active and ready.")
} else {
stop("Failed to establish a connection to the database.")
}
# Define the function to retrieve run details, including reference genome information
getRunDetails <- function(run_id) {
query <- sprintf("
SELECT
r.run_id,
r.run_date,
r.status,
r.sample_id,
s.collection_date,
s.source,
a.analysis_type,
a.result,
m.key,
m.value AS metadata_value,
rg.name AS genome_name,
rg.version AS genome_version,
sc.component_name,
sc.component_version,
gl.commit_id
FROM
Runs r
JOIN Samples s ON r.sample_id = s.sample_id
JOIN Analyses a ON r.run_id = a.run_id
JOIN Metadata m ON r.run_id = m.run_id
JOIN SystemComponents sc ON r.run_id = sc.run_id
JOIN GitLog gl ON sc.component_id = gl.component_id
LEFT JOIN ReferenceGenomes rg ON m.value = rg.reference_id AND m.key = 'Reference Genome'
WHERE
r.run_id = '%s'", run_id)
dbGetQuery(db, query)
}
# Retrieve run details
run_details <- getRunDetails(run_id)
print(run_details)
# kable(run_details, format="latex", longtable = FALSE, booktabs=FALSE,  position = "H") %>%
# kable_styling(latex_options="scale_down")
df <- readRDS(file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
df$linked_to_network <- "No"
# df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle, content) |> head()
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, content)
# df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle, content) |> head()
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, content)
```{r setup, echo=FALSE, message=FALSE}
library(DBI)
library(knitr)
library(dplyr)
library(igraph)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
kable <- function(data) {
knitr::kable(data, format="latex", longtable = FALSE, booktabs=FALSE, row.names = FALSE) %>%
kable_styling(latex_options =c("striped", "scale_down", "HOLD_position"))
}
# Define global variables for the database connection to ensure it stays open
run_id <- params$run_id
dbname <- "DNAsnake_IVDR.db"
# Connect to the database
db <- dbConnect(RSQLite::SQLite(), dbname = dbname)
# Ensure the database connection is valid
if (dbIsValid(db)) {
print("SQL database connection is active and ready.")
} else {
stop("Failed to establish a connection to the database.")
}
# Define the function to retrieve run details, including reference genome information
getRunDetails <- function(run_id) {
query <- sprintf("
SELECT
r.run_id,
r.run_date,
r.status,
r.sample_id,
s.collection_date,
s.source,
a.analysis_type,
a.result,
m.key,
m.value AS metadata_value,
rg.name AS genome_name,
rg.version AS genome_version,
sc.component_name,
sc.component_version,
gl.commit_id
FROM
Runs r
JOIN Samples s ON r.sample_id = s.sample_id
JOIN Analyses a ON r.run_id = a.run_id
JOIN Metadata m ON r.run_id = m.run_id
JOIN SystemComponents sc ON r.run_id = sc.run_id
JOIN GitLog gl ON sc.component_id = gl.component_id
LEFT JOIN ReferenceGenomes rg ON m.value = rg.reference_id AND m.key = 'Reference Genome'
WHERE
r.run_id = '%s'", run_id)
dbGetQuery(db, query)
}
# Retrieve run details
run_details <- getRunDetails(run_id)
print(run_details)
# kable(run_details, format="latex", longtable = FALSE, booktabs=FALSE,  position = "H") %>%
# kable_styling(latex_options="scale_down")
```
df <- readRDS(file = "../eurlex_scraper/data/EU_Regulation_Articles.Rds")
df$linked_to_network <- "No"
# df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, subtitle, content) |> head()
df <- df |> dplyr::filter(grepl("^art", article)) |> dplyr::select(title, content)
# Custom function to remove excess whitespaces
remove_excess_whitespace <- function(text) {
sapply(text, function(x) {
gsub("\\s+", " ", x)
})
}
# Remove excess whitespaces from the content column
df$content <- remove_excess_whitespace(df$content)
# Custom function to truncate text at a specified length
truncate_text <- function(text, length = 100) {
sapply(text, function(x) {
if (nchar(x) > length) {
return(paste0(substr(x, 1, length), "..."))
} else {
return(x)
}
})
}
# Truncate the content column to a maximum of 60 characters
df$content <- truncate_text(df$content, length = 100)
# display
kable(df[1:10, ])
# display
kable(df[1:10, ])
cat("   skipping to end...\n")
# display
kable(df[1:10, ])
cat("   skipping to end...\n")
kable(df[104:113, ])
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
# Displaying the run details data frame
kable(run_details)
# Fetching details from the Runs and Samples tables
sample_details <- dbGetQuery(db, sprintf("SELECT r.sample_id, s.collection_date, s.source
FROM Runs r JOIN Samples s ON r.sample_id = s.sample_id
WHERE r.run_id = '%s'", params$run_id))
# Display the sample details
kable(sample_details)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
# You might need to adjust this query to match your database schema
system_details <- dbGetQuery(db, paste("SELECT * FROM SystemComponents WHERE run_id = '", params$run_id, "'", sep = ""))
kable(system_details)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
# Assuming a table exists that logs all git commits relevant to each run
git_log <- dbGetQuery(db, paste("SELECT * FROM GitLog WHERE run_id = '", params$run_id, "'", sep = ""))
kable(git_log)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
# Check if the reference genome ID is present in the metadata
genome_id <- run_details %>%
filter(key == "Reference Genome") %>%
pull(metadata_value) %>%
unique()  # This should give us the unique genome ID used
# If a genome ID is present, fetch the details from the ReferenceGenomes table
if (length(genome_id) > 0) {
ref_genome_query <- paste("SELECT * FROM ReferenceGenomes WHERE reference_id = '", genome_id, "'", sep = "")
ref_genome_details <- dbGetQuery(db, ref_genome_query)
if (nrow(ref_genome_details) > 0) {
cat("Reference Genome Details for run ID:", params$run_id, ":\n")
kable(ref_genome_details)
# kable(ref_genome_details, format="latex", longtable = FALSE, booktabs=FALSE,  position = "H") %>%
# kable_styling(latex_options="scale_down")
} else {
print("No reference genome details found for the provided genome ID.")
}
} else {
print("No reference genome ID found in the metadata for this run.")
}
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), width=60)
audit_trail <- dbGetQuery(db, paste("SELECT * FROM AuditTrail WHERE run_id = '", params$run_id, "'", sep = ""))
kable(audit_trail)
# Define nodes with variable names
nodes <- data.frame(name = unique(c(
paste0("r.run_id: ", run_details$run_id),
paste0("r.sample_id: ", run_details$sample_id),
paste0("s.source: ", run_details$source),
paste0("a.analysis_type: ", run_details$analysis_type),
paste0("m.key: ", run_details$key),
paste0("rg.genome_name: ", run_details$genome_name),
paste0("sc.component_name: ", run_details$component_name),
paste0("gl.commit_id: ", run_details$commit_id)
)))
# Define edges with variable names
edges <- data.frame(
from = c(
paste0("r.run_id: ", run_details$run_id),
paste0("r.run_id: ", run_details$run_id),
paste0("r.run_id: ", run_details$run_id),
paste0("r.run_id: ", run_details$run_id),
paste0("r.run_id: ", run_details$run_id),
paste0("r.run_id: ", run_details$run_id),
paste0("r.run_id: ", run_details$run_id),
paste0("r.sample_id: ", run_details$sample_id)
),
to = c(
paste0("r.sample_id: ", run_details$sample_id),
paste0("s.source: ", run_details$source),
paste0("a.analysis_type: ", run_details$analysis_type),
paste0("m.key: ", run_details$key),
paste0("rg.genome_name: ", run_details$genome_name),
paste0("sc.component_name: ", run_details$component_name),
paste0("gl.commit_id: ", run_details$commit_id),
paste0("s.source: ", run_details$source)
)
)
# Create a graph from the edge list
network_graph <- graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE)
# Plot the graph
plot(network_graph,
layout = layout_with_fr(network_graph),
vertex.size = 20,
vertex.color = "lightblue",
vertex.frame.color = "#ffffff",
vertex.label.color = "black",
edge.arrow.size = 0.5,
main = "Database relationship network")
# Plot the graph
p <- plot(network_graph,
layout = layout_with_fr(network_graph),
vertex.size = 20,
vertex.color = "lightblue",
vertex.frame.color = "#ffffff",
vertex.label.color = "black",
edge.arrow.size = 0.5,
main = "Database relationship network")
view(p)
p
# Plot the graph
p <- plot(network_graph,
layout = layout_with_fr(network_graph),
vertex.size = 20,
vertex.color = "lightblue",
vertex.frame.color = "#ffffff",
vertex.label.color = "black",
edge.arrow.size = 0.5,
main = "Database relationship network")
# Open a PNG device
png("network_graph.png", width = 800, height = 600)
p
# Close the device
dev.off()
# Open a PNG device
png("network_graph.png", width = 800, height = 600)
plot(network_graph,
layout = layout_with_fr(network_graph),
vertex.size = 20,
vertex.color = "lightblue",
vertex.frame.color = "#ffffff",
vertex.label.color = "black",
edge.arrow.size = 0.5,
main = "Database relationship network")
# Close the device
dev.off()
??plot()
